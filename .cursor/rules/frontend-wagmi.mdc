---
globs: frontend/*
alwaysApply: false
---

# Frontend Development Rules for Base MiniApp & MiniKit

You are an expert in Solidity, TypeScript, Node.js, Next.js 14 App Router, React, Viem v2, Wagmi v2, Shadcn UI, Radix UI, Tailwind Aria, Base MiniApp development, and Farcaster MiniApp SDK.

## Core Technologies & Frameworks
- **Base Ecosystem**: Base Mainnet, Base Sepolia, Base Preconf
- **MiniApp Framework**: Farcaster MiniApp SDK, MiniKit
- **Web3 Stack**: Wagmi v2, Viem v2, OnchainKit
- **Frontend**: Next.js 14 App Router, React 19, TypeScript
- **UI/UX**: Shadcn UI, Radix UI, Tailwind CSS, Tailwind Aria

## Key Principles
- Write concise, technical responses with accurate TypeScript examples
- Use functional, declarative programming. Avoid classes
- Prefer iteration and modularization over duplication
- Use descriptive variable names with auxiliary verbs (e.g., isLoading)
- Use lowercase with dashes for directories (e.g., components/auth-wizard)
- Favor named exports for components
- Use the Receive an Object, Return an Object (RORO) pattern

## JavaScript/TypeScript Best Practices
- Use "function" keyword for pure functions. Omit semicolons
- Use TypeScript for all code. Prefer interfaces over types. Avoid enums, use maps
- File structure: Exported component, subcomponents, helpers, static content, types
- Avoid unnecessary curly braces in conditional statements
- For single-line statements in conditionals, omit curly braces
- Use concise, one-line syntax for simple conditional statements (e.g., if (condition) doSomething())

## Error Handling and Validation
- Prioritize error handling and edge cases:
  - Handle errors and edge cases at the beginning of functions
  - Use early returns for error conditions to avoid deeply nested if statements
  - Place the happy path last in the function for improved readability
  - Avoid unnecessary else statements; use if-return pattern instead
  - Use guard clauses to handle preconditions and invalid states early
  - Implement proper error logging and user-friendly error messages
  - Consider using custom error types or error factories for consistent error handling

## React/Next.js Development
- Use functional components and TypeScript interfaces
- Use declarative JSX
- Use function, not const, for components
- Use Shadcn UI, Radix, and Tailwind Aria for components and styling
- Implement responsive design with Tailwind CSS
- Use mobile-first approach for responsive design
- Place static content and interfaces at file end
- Use content variables for static content outside render functions
- Minimize 'use client', 'useEffect', and 'setState'. Favor RSC
- Use Zod for form validation
- Wrap client components in Suspense with fallback
- Use dynamic loading for non-critical components
- Optimize images: WebP format, size data, lazy loading
- Model expected errors as return values: Avoid using try/catch for expected errors in Server Actions. Use useActionState to manage these errors and return them to the client
- Use error boundaries for unexpected errors: Implement error boundaries using error.tsx and global-error.tsx files to handle unexpected errors and provide a fallback UI
- Use useActionState with react-hook-form for form validation
- Code in services/ dir always throw user-friendly errors that tanStackQuery can catch and show to the user
- Use next-safe-action for all server actions:
  - Implement type-safe server actions with proper validation
  - Utilize the `action` function from next-safe-action for creating actions
  - Define input schemas using Zod for robust type checking and validation
  - Handle errors gracefully and return appropriate responses
  - Use import type { ActionResponse } from '@/types/actions'
  - Ensure all server actions return the ActionResponse type
  - Implement consistent error handling and success responses using ActionResponse

## Base MiniApp & MiniKit Specific Guidelines

### MiniApp Configuration
- Always use the `minikitConfig` object for MiniApp metadata
- Ensure proper Base network configuration in wagmi config
- Use Base Preconf for testing, Base Mainnet for production
- Configure proper chain IDs: Base Mainnet (8453), Base Sepolia (84532), Base Preconf (8453)
- Set up proper RPC endpoints for Base networks

### Farcaster MiniApp SDK Integration
- Use `@farcaster/miniapp-sdk` for MiniApp functionality
- Implement proper MiniApp lifecycle management
- Handle MiniApp context and user authentication
- Use `@farcaster/miniapp-wagmi-connector` for wallet integration
- Implement proper error handling for MiniApp-specific errors

### OnchainKit Integration
- Use `@coinbase/onchainkit` for Base-specific components
- Implement proper wallet connection flows
- Use OnchainKit's Base-specific utilities
- Handle Base network switching properly
- Implement proper transaction handling for Base

### Wagmi Configuration for Base
```typescript
// Always include Base networks in wagmi config
const chains = [basePreconf, baseSepolia, base] as const

export const wagmiConfig = createConfig({
  chains,
  transports: {
    [basePreconf.id]: http(),
    [baseSepolia.id]: http(),
    [base.id]: http(),
  },
  connectors: [
    miniAppConnector(),
    coinbaseWallet({ appName: "Your App" }),
  ],
})
```

### MiniApp Development Patterns
- Use MiniApp-specific hooks and utilities
- Implement proper MiniApp navigation
- Handle MiniApp-specific user interactions
- Use MiniApp context for user data
- Implement proper MiniApp lifecycle hooks

### Base Network Handling
- Always check network before transactions
- Implement proper network switching
- Handle Base-specific transaction types
- Use Base-specific gas estimation
- Implement proper error handling for Base network issues

### MiniApp UI/UX Guidelines
- Design for mobile-first experience
- Use Base branding guidelines
- Implement proper loading states
- Handle MiniApp-specific navigation
- Use Base color schemes and typography

### Security Considerations
- Validate all MiniApp inputs
- Implement proper authentication flows
- Handle MiniApp-specific security concerns
- Use proper error boundaries for MiniApp errors
- Implement proper transaction validation

## Key Conventions
1. Rely on Next.js App Router for state changes
2. Prioritize Web Vitals (LCP, CLS, FID)
3. Minimize 'use client' usage:
   - Prefer server components and Next.js SSR features
   - Use 'use client' only for Web API access in small components
   - Avoid using 'use client' for data fetching or state management
4. Always use Base networks for blockchain interactions
5. Implement proper MiniApp lifecycle management
6. Use OnchainKit components for Base-specific functionality

## Development Workflow
- Use Base Sepolia for development and testing
- Use Base Preconf for MiniApp testing
- Deploy to Base Mainnet for production
- Always test MiniApp functionality in Farcaster environment
- Use proper MiniApp debugging tools

Refer to Next.js documentation for Data Fetching, Rendering, and Routing best practices.
Refer to Base documentation for Base-specific development guidelines.
Refer to Farcaster MiniApp documentation for MiniApp-specific implementation details.
  